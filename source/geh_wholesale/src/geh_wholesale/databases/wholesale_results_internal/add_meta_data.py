from pyspark.sql import DataFrame
from pyspark.sql.functions import col, lit
from pyspark.sql.types import StringType

from geh_wholesale.calculation.calculator_args import CalculatorArgs
from geh_wholesale.constants import Colname


def add_metadata(
    args: CalculatorArgs,
    column_group_for_calculation_result_id: list[str],
    df: DataFrame,
    table_name: str,
) -> DataFrame:
    df = (
        df.withColumn(Colname.calculation_id, lit(args.calculation_id))
        .withColumn(Colname.calculation_type, lit(args.calculation_type.value))
        .withColumn(
            Colname.calculation_execution_time_start,
            lit(args.calculation_execution_time_start),
        )
    )
    df = _add_calculation_result_id(df, column_group_for_calculation_result_id, table_name)

    return df


def _add_calculation_result_id(
    df: DataFrame,
    column_group_for_calculation_result_id: list[str],
    table_name: str,
) -> DataFrame:
    """Add a unique id to the dataframe based on the selected columns and the table name.

    The Databricks engine is not fond of non-deterministic functions like 'uuid()' when it comes to rerunning steps due to failures.
    To avoid the non-deterministic function the result id is now generated by concatenating values of selected
    partition columns and the table name. Then the concatenated string is converted into a deterministic uuid using uuid5.

    The following implementation adds two temporary columns to the dataframe, one for storing the table name and one for storing the concatenated string.
    The table name is used as a part of the concatenated string to ensure uniqueness.
    """
    # The imports must be added locally in order to be imported correctly.
    import uuid

    import pyspark.sql.functions as f

    namespace = uuid.UUID("681fd884-0a2e-4dc2-96ea-c61c3683449c")

    def _generate_uuid5(concatenated_str: str) -> str:
        return str(uuid.uuid5(namespace, concatenated_str))

    # User defined function to generate a deterministic uuid5 from a string
    uuid5_udf = f.udf(_generate_uuid5, StringType())

    # Add the column "table_name" with the value of the actual table name
    table_name_column = "table_name"
    df = df.withColumn(table_name_column, lit(table_name))

    # Add string "table_name" to the list of columns to be concatenated
    column_group_for_calculation_result_id.append(table_name_column)

    columns_for_uuid_generation = [col(c) for c in column_group_for_calculation_result_id]

    concatenated_column = "concatenated_column"
    df = df.withColumn(
        concatenated_column,
        f.concat_ws("", *columns_for_uuid_generation),
    )

    df = df.withColumn(
        Colname.result_id,
        uuid5_udf(col(concatenated_column)),
    )

    return df.drop(concatenated_column).drop(table_name_column)
